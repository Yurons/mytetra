<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">
<p><span style="font-family:Sans Serif;"><span style="font-size:9pt;">	</span></span><span style="font-family:Courier New,courier;">Команда <span style="color:#c00000;">who</span> выводит список пользователей, которые в настоящий момент зарегистрированы в системе (вошли в систему)</span><span style="font-family:Sans Serif;"> </span></p>
<p>рограмма, выдающая информацию о пользователях, работавших в системе в последнее время - last</p>
<p>Выход из системы logout или <span style="color:#ff0000;">Ctrl+D</span></p>
<p>Команды оказали одинаковый эффект, но работают они по-разному: &quot; ^C &quot; посылает программе, которая считывает с клавиатуры сигнал аварийного прекращения работы, а &quot; ^D &quot; сообщает ей, что ввод данных с клавиатуры закончен и можно продолжать работу (поскольку программа cat больше ничего не делает, она завершается самостоятельно, естественным путем). Можно считать, что &quot; <span style="color:#c00000;">^C</span> &quot; - это сокращение от &quot;Cancel&quot;, а &quot; ^D &quot; - от &quot;Done&quot;.</p>
<p>Команда cal выводит календарь на текущий месяц</p>
<p>&nbsp;<p>В bash тип команды можно определить с помощью команды type. Собственные команды bash называются builtin (встроенная команда) , а для утилит выводится путь, содержащий название каталога, в котором лежит файл с соответствующей программой, и имя этой программы</p>
<p>&nbsp;<p>Страница руководства занимает, как правило, больше одной страницы экрана. Для того чтобы читать было удобнее, man запускает программу постраничного просмотра текстов - less. Управлять программой less просто: страницы перелистываются пробелом, а когда читать надоест, надо нажать &quot; q &quot; (Quit). Перелистывать страницы можно и клавишами Page Up/Page Down, для сдвига на одну строку вперед можно применять Enter или стрелку вниз, а на одну строку назад - стрелку вверх. Переход на начало и конец текста выполняется по командам &quot; g &quot; и &quot; G &quot; соответственно (Go). Полный список того, что можно делать с текстом в less, выводится по команде &quot; H &quot; (Help). Еще команды для поиска </p>
<p>/pattern          *  Search forward for (N-th) matching line.</p>
<p>  ?pattern          *  Search backward for (N-th) matching line.</p>
<p>  n                 *  Repeat previous search (for N-th occurrence).</p>
<p>  N                 *  Repeat previous search in reverse direction.</p>
<p>  ESC-n             *  Repeat previous search, spanning files.</p>
<p>  ESC-N             *  Repeat previous search, reverse dir. &amp; spanning files.</p>
<p>  ESC-u                Undo (toggle) search highlighting.</p>
<p>  &amp;pattern          *  Display only matching lines</p>
<p>&nbsp;<p>Как и команда apropos, whatis ищет подстроку в некоторой базе данных, состоящей из полей NAME всех страниц помощи в системе. Различие между ними в том, что whatis - только среди имен объектов (в левых частях полей NAME ), а apropos - по всей базе.</p>
<p>&nbsp;<p>Info. Одна или несколько страниц, которые можно перелистывать клавишей Пробел или Page Up/Page Down - это узел (node). Узел содержит обычный текст и меню (menu) - список ссылок на другие узлы, лежащие в дереве на более низком уровне. Ссылки внутри документа имеют вид &quot;* имя_узла::&quot; и перемещать по ним курсор можно клавишей Tab, а переходить к просмотру выбранного узла - клавишей Enter. Вернуться к предыдущему просмотренному узлу можно клавишей &quot; l &quot; (oт &quot;Last&quot;). И, главное, выйти из программы info можно, нажав &quot; q &quot; (&quot;Quit&quot;). Более подробную справку об управлении программой info можно в любой момент получить у самой info, нажав &quot; ?&quot;.</p>
<p>&nbsp;<p>сгруппировал ключи, написав &quot; -at &quot; вместо &quot; -a -t &quot;. Многие утилиты позволяют уменьшать длину командной строки подобным образом. Если встречается параметрический ключ, он должен быть последним в группе, а его значение - следовать, как и полагается, после. Группировать можно только однобуквенные ключи</p>
<p>&nbsp;<p>В Linux имена файлов и каталогов могут быть длиной не более 256 символов, и могут содержать любые символы, кроме &quot; / &quot;.</p>
<p>&nbsp;<p>В файловой системе Linux нет никаких предписаний по поводу расширения: в имени файла может быть любое количество точек (в том числе ни одной), а после последней точки может стоять любое количество символов</p>
<p>&nbsp;<p>Есть несколько символов, допустимых в именах файлов и каталогов, которые нужно использовать с осторожностью. Это так называемые спецсимволы &quot; * &quot;, &quot; \ &quot;, &quot; &amp; &quot;, &quot; &lt; &quot;, &quot; &gt; &quot;, &quot; ; &quot;, &quot; ( &quot;, &quot; ) &quot;, &quot; | &quot;, а также символы пробела и табуляции</p>
<p>&nbsp;<p>Краткое описание стандартной иерархии каталогов Linux можно получить, отдав команду man hier. Полный текст и последнюю редакцию стандарта FHS можно прочесть по адресу http://www.pathname.com/fhs/.</p>
<p>&nbsp;<p>ls (сокращение от англ. &quot;list&quot; - &quot;список&quot;):</p>
<p>cd (от англ. &quot;change directory&quot; - &quot;сменить каталог &quot;)</p>
<p>&nbsp;<p>Узнать номер индексного дескриптора любого файла можно при помощи все той же утилиты ls с ключом -i</p>
<p>&nbsp;<p>Более того, имя (или имена) файла в его индексном дескрипторе не указаны. В файловой системе Ext2 имена файлов хранятся в каталогах: каждый каталог представляет собой список имен файлов и номеров их индексных дескрипторов. Жесткую ссылку (имя файла, хранящееся в каталоге ) можно представлять как каталожную карточку, на которой указан номер индексного дескриптора - идентификатор файла</p>
<p>&nbsp;<p>Узнать, куда указывает символьная ссылка, можно при помощи утилиты realpath</p>
<p>&nbsp;<p><strong><span style="color:#000000;">5. Лекция: Доступ процессов к файлам и каталогам</span></strong></p>
<p>&nbsp;<p>идентификатор процесса ( p rocess id entificator, PID ).</p>
<p>&nbsp;<p>Для просмотра своих процессов можно воспользоваться утилитой <span style="color:#800000;">ps</span><span style="color:#000000;"> (&quot; p rocess s tatus&quot;)</span></p>
<p>&nbsp;<p>Здесь Мефодий вызвал <span style="color:#800000;">ps </span><span style="color:#000000;">с ключом &quot; -</span><span style="color:#800000;">f &quot; (&quot; f ull</span><span style="color:#000000;">&quot;), чтобы добыть побольше информации</span></p>
<p>&nbsp;<p>В поле PPID (&quot; p arent p rocess id entificator&quot;) указан идентификатор родительского процесса, т. е. процесса, породившего данный.</p>
<p>&nbsp;<p>активный процесс, foreground process - процесс, имеющий возможность вводить данные с терминала..</p>
<p>&nbsp;<p>Фоновый процесс, background process - процесс, не имеющий возможности вводить данные с терминала. Пользователь может запустить любое, но не превосходящее заранее заданное в системе, число фоновых процессов.</p>
<p>&nbsp;<p>Сигнал - короткое сообщение, посылаемое системой или процессом другому процессу. Обрабатывается асинхронно специальной подпрограммой-обработчиком. Если процесс не обрабатывает сигнал самостоятельно, это делает система.</p>
<p>&nbsp;<p>Два сигнала –<span style="color:#c00000;"> 9 ( KILL )</span><span style="color:#000000;"> и </span><span style="color:#c00000;">19 ( STOP )</span><span style="color:#000000;"> –</span><span style="color:#c00000;"> всегда обрабатывает система</span><span style="color:#000000;">. Первый из них нужен для того, чтобы убить процесс наверняка (отсюда и название). Сигнал STOP приостанавливает процесс: в таком состоянии процесс не удаляется из таблицы процессов, но и не выполняется до тех пор, пока не получит сигнал 18 ( CONT ) – после чего продолжит работу. В Linux сигнал STOP можно передать активному процессу с помощью управляющего символа &quot; ^Z &quot;:</span></p>
<p>&nbsp;<p>В ps он использовал новый ключ – &quot; -H &quot; (&quot; H ierarchy&quot;, &quot;иерархия&quot;), который добавляет в выдачу ps отступы, показывающие отношения &quot;родитель–потомок&quot; между процессами</p>
<p>&nbsp;<p>Когда Мефодий расправился и с ними – с помощью сигнала 1 ( HUP, то есть &quot; H ang UP &quot;, &quot;повесить&quot;1) )</p>
<p>&nbsp;<p>Суть всех трех видов доступа к каталогу менее очевидна, чем суть доступа к файлу. Вкратце она такова: доступ по чтению – это возможность просмотреть содержимое каталога (список файлов), доступ по записи – это возможность изменить содержимое каталога, а доступ для использования – возможность воспользоваться этим содержимым: во-первых, сделать этот каталог текущим, а во-вторых, обратиться за доступом к содержащемуся в нем файлу:</p>
<p>&nbsp;<p><strong>pwd</strong> ( <strong>p</strong> rint <strong>w</strong> ork <strong>d</strong> irectory) </p>
<p>chmod – с ключом &quot; -R &quot; (&quot; R &quot; здесь большое, а не маленькое, потому что &quot; -r &quot; уже занято: означает запрет чтения)</p>
<p>&nbsp;<p>Утилита id, которой воспользовался Мефодий, выводит входное имя пользователя и соответствующий ему UID, а также группу по умолчанию и полный список групп, членом которых он является.</p>
<p>&nbsp;<p>использовал ключ &quot; -d &quot; ( d irectory) для того, чтобы ls выводил информацию не о содержимом каталога tmp, а о самом этом каталоге</p>
<p>&nbsp;<p>Наименьшая длина строки передается <span style="color:#c00000;">strings</span><span style="color:#000000;"> ключом &quot; -n &quot;</span></p>
<p>&nbsp;<p><strong>7. Лекция: Работа с текстовыми данными</strong></p>
<p>&nbsp;<p>Каждый процесс Linux получает при старте <strong>три</strong> &quot;файла&quot;, открытых для него системой. Первый из них (дескриптор 0 ) открыт на <strong>чтение</strong>, это стандартный ввод процесса. Именно со стандартным вводом работают все операции чтения, если в них не указан дескриптор файла. Второй (дескриптор 1 ) - открыт на <strong>запись</strong>, это стандартный вывод процесса. С ним работают все операции записи, если дескриптор файла не указан в них явно. Наконец, третий поток данных (дескриптор 2 ) предназначается для вывода диагностических сообщений, он называется <strong>стандартный вывод ошибок</strong>. Поскольку эти три дескриптора уже открыты к моменту запуска процесса, первый файл, открытый <strong>самим</strong> процессом, будет, скорее всего, иметь дескриптор 3.</p>
<p>&nbsp;<p>В этом примере важен порядок перенаправлений: в командной строке Мефодий сначала указал, куда перенаправить стандартный вывод (&quot; &gt; cat.info &quot;) и только потом велел направить туда же стандартный вывод ошибок. Сделай он наоборот (&quot; 2&gt;&amp;1 &gt; cat.info &quot;), результат получился бы неожиданный: в файл попал бы только стандартный вывод, а диагностические сообщения появились бы на терминале. Однако логика здесь железная: на момент выполнения операции &quot; 2&gt;&amp;1 &quot; стандартный вывод был связан с терминалом, значит, после ее выполнения стандартный вывод ошибок тоже будет связан с терминалом. А последующее перенаправление стандартного вывода в файл, конечно, никак не отразится на стандартном выводе ошибок. Номер в конструкции &quot; &amp;номер &quot; - это номер открытого дескриптора. Если бы упомянутая выше утилита, записывающая в четвертый дескриптор, была написана на shell, в ней бы использовались перенаправления вида &quot; &gt;&amp;4 &quot;. Чтобы не набирать громоздкую конструкцию &quot; &gt; файл 2&gt;&amp;1 &quot; в bash используются сокращения: &quot; &amp;&gt; файл &quot; или, что то же самое, &quot; &gt;&amp; файл &quot;.</p>
<p>&nbsp;<p>Необходимо помнить, что операция &quot; &gt; &quot; <strong>деструктивна</strong>: она всегда создает файл нулевой длины. Поэтому для, допустим, сортировки данных <strong>в файле</strong> надо применять последовательно sort &lt; файл &gt; новый_файл и mv новый_файл файл. Команда вида команда &lt; файл &gt; тот_же_файл просто урежет его до нулевой длины!</p>
<p>&nbsp;<p>Иногда заведомо известно, что какие-то данные, выведенные программой, <strong>не понадобятся</strong>. Например, предупреждения со стандартного вывода ошибок. В этом случае можно перенаправить <strong>стандартный вывод ошибок в файл-дырку</strong>, специально предназначенный для уничтожения данных - /dev/null. Все, что записывается в этот файл, просто будет выброшено и <strong>нигде не сохранится</strong>:</p>
<p>&nbsp;<p><strong>Канал (pipe) </strong>- неделимая пара дескрипторов (входной и выходной), связанных друг с другом таким образом, что данные, записанные во входной дескриптор, будут немедленно доступны на чтение с выходного дескриптора.</p>
<p>&nbsp;<p>Для замены одних символов другими предназначена утилита <strong>tr</strong> (сокращение от англ. &quot;<strong>translate</strong>&quot; - &quot;преобразовывать, переводить&quot;), работающая как фильтр</p>
<p>&nbsp;<p>Помимо простой замены отдельных символов, возможна замена последовательностей (слов). Специально для этого предназначен потоковый редактор <strong>sed</strong> (сокращение от англ. &quot;<strong>stream editor</strong>&quot;).</p>
<p>&nbsp;<p>Полученные в конвейере данные можно превратить в руководство к действию для компьютера. Например, для каждой полученной со стандартного ввода строки можно запустить какую-нибудь команду, передав ей эту строку в качестве параметра. Для этой цели служит утилита <strong>xargs</strong>:</p>
<p>&nbsp;<p><strong>8. Лекция: Возможности командной оболочки</strong></p>
<p>. Одно из таких удобств - возможность редактировать вводимую строку с помощью клавиши <strong>Backspace</strong> (удаление последнего символа), &quot; <strong>^W</strong> &quot; (удаление слова) и &quot; <strong>^U</strong> &quot; (удаление всей строки) </p>
<p>&nbsp;<p>Попытка &quot;наскоком&quot; узнать все про работу в командной строке принесла некоторую пользу. Во-первых, перемещаться в командной строке можно не только по одному символу вперед и назад, но и по словам: команды <strong>escF/escB</strong> или <strong>Alt+F/Alt+B</strong> соответственно (от <strong>forward</strong> и <strong>backward</strong>), работают также клавиши <strong>home</strong> и <strong>end</strong>, или, что то же самое, &quot; <strong>^A</strong> &quot; и &quot; <strong>^E</strong> &quot;. А во-вторых, помимо работы с одной командной строкой, существует еще немало других удобств, о которых и пойдет речь в этой лекции.</p>
<p>&nbsp;<p>а выполнить поиск с помощью команды &quot; <strong>^R</strong> &quot; (<strong>reverse search</strong>)</p>
<p>&nbsp;<p><strong>Шаблон (pattern)</strong> - строка специального формата, используемая в процедурах текстового поиска. Говорят, что строка соответствует шаблону, если можно по определенным правилам каждому символу строки поставить в соответствие символ шаблона. В Linux наиболее популярны шаблоны в формате командного интерпретатора и регулярные выражения.</p>
<p>&nbsp;<p>Просмотреть окружение в bash можно с помощью команды <strong>set</strong>. Большинство заранее определенных переменных используются либо самой командной оболочкой, либо утилитами системы, поэтому их изменение приводит к тому, что оболочка или утилиты начинают работать <strong>несколько иначе</strong>.</p>
<p>&nbsp;<p>Записать значение в переменную можно с помощью операции <strong>присваивания</strong>, а прочесть его оттуда - с помощью операции <strong>подстановки</strong> вида <em>$переменная</em>:</p>
<p>&nbsp;<p>Переменных окружения, влияющих на работу разных утилит, довольно много. Например, переменные семейства LC_ (полный их список выдается командой <strong>locale</strong> )</p>
<p>&nbsp;<p>Некоторые переменные окружения предназначены специально для bash: они задают его свойства и особенности поведения. Таковы переменные семейства <strong>PS</strong> (Prompt String). В этих переменных хранится строка-подсказка, которую командный интерпретатор выводит в разных состояниях. В частности, содержимое <strong>PS1</strong> - это подсказка, которую shell показывает, когда вводит командную строку, а <strong>PS2</strong> - когда пользователь нажимает Enter, а интерпретатор по какой-то причине считает, что ввод командной строки не завершен (например, не закрыты кавычки). С <strong>$PS2</strong> (символом &quot; &gt; &quot;)</p>
<p>&nbsp;<p>Список всех функций readline можно узнать у bash по команде<strong> bind -l</strong>, а список всех привязок этих функций к клавиатурным последовательностям - по команде <strong>bind -p</strong>.</p>
<p>&nbsp;<p><strong>tput</strong>, которая обращается к переменной TERM и базе данных по терминалам terminfo и готова выдать верную для любого данного терминала информацию по kpp (key previous page) и knp (key next page)</p>
<p>&nbsp;<p>Что касается bash, то структура его стартовых файлов сложнее. Прежде всего, <strong>~/.profile</strong> выполняется, только если в домашнем каталоге нет файла <strong>.bash_profile</strong> или <strong>.bash_login</strong>, иначе стартовый сценарий берется оттуда. В эти файлы можно помещать команды, несовместимые с другими версиями shell, например, управление сокращениями или привязку функций к клавишам. Кроме того, каждый интерактивный (взаимодействующий с пользователем), но не стартовый bash выполняет системный и персональный конфигурационные сценарии <strong>/etc/bashrc</strong> и <strong>~/.bashrc</strong>. Чтобы стартовый bash также выполнял<strong> ~/.bashrc</strong>, соответствующую команду необходимо вписать в <strong>~/.bash_profile</strong>. Далее, каждый неинтерактивный (запущенный для выполнения сценария ) bash сверяется с переменной окружения <strong>BASH_ENV</strong> и, если в этой переменной записано имя существующего файла, выполняет команды оттуда. Наконец, при завершении стартового bash выполняются команды из файла <strong>~/.bash_logou</strong>t.</p>
<p>&nbsp;<p><strong>9. Лекция: Текстовые редакторы</strong></p>
<p>Название <strong>Vi</strong> происходит от <strong>visual editor</strong>, &quot;визуальный&quot;, экранный редактор</p>
<p>&nbsp;<p>Наберите <strong>:!</strong> и затем <strong>внешнюю команду, которую следует выполнить</strong></p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>&nbsp;
</p></body></html>
