<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">
<p><strong><span style="font-family:Sans Serif;"><span style="font-size:12pt;"><a href="http://www.ashep.org/2011/bystryj-kurs-ipv6-v-linux/">Быстрый курс IPv6 в Linux</a> </span></span></strong></p>
<p>&nbsp;<p><span style="font-size:9pt;">Возможно вы привыкли к IPv4, однако нравится вам это или нет, постепенно наступает эра IP шестой версии. Засучите рукава, поплюйте на ладони и приготовьтесь поработать. Ядро, начиная с версии 2.1, обладает поддержкой IPv6, так что вам ничего не нужно доустанавливать. Убедитесь лишь, что в вашей системе  установлены программы ping6, ip и ifconfig. И давайте сразу договоримся: здесь мы говорим не об «IP», а об «IP-адресах». IP — это Internet Protocol, а никак не IP-адреса. Как говорит моя бабушка, небрежность в разговоре равносильна небрежности в делах, что ни к чему хорошему не приводит.</span></p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Преимущества IPv6</p>
<p>&nbsp;<p>Итак, чем же IPv6 лучше своего предшественника? Кроме того, что мы избавляемся от проблем в IPv4-адресацией, у нас теперь есть:</p>
<p>отсутствие головной боли с частными подсетями;</p>
<p>использование NAT скорее исключение, чем правило;</p>
<p>упрощённая маршрутизация;</p>
<p>говорим «прощай» DHCP.</p>
<p>&nbsp;<p>Основным недостатком IPv6 можно назвать длинные адреса в шестнадцатиричном виде. Четыре фрагмента адреса IPv4, разделённые точками, легки для запоминания, а вот восемь кусков шестнадцатиричных чисел запомнить куда труднее.</p>
<p>Моя система поддерживает IPv6?</p>
<p>&nbsp;<p>Как узнать, включена ли поддержка IPv6 в вашем Linux? Очень просто:</p>
<p>$ cat /proc/net/if_inet6</p>
<p>000000000000000000000000000000 01 01 80 10 80       lo</p>
<p>fe80000000000000020b6afffeef7e 8d 02 40 20 80     eth0</p>
<p>&nbsp;<p>Если вы увидите в своей системе вывод, подобный этому — значит всё отлично, поддержка IPv6 в вашей системе включёна. Вообще, все современные Linux-дистрибутивы поддерживают IPv6 «из коробки».</p>
<p>Пинг IPv6</p>
<p>&nbsp;<p>Если вам нужно выполнить пинг IPv6-системы, вам понадобится утилита ping6. Следующая команда отправляет два пакета к localhost:</p>
<p>$ ping6 -c2 ::1</p>
<p>PING ::1(::1) 56 data bytes</p>
<p>64 bytes from ::1: icmp_seq=1 ttl=64 time=0.043 ms</p>
<p>64 bytes from ::1: icmp_seq=2 ttl=64 time=0.054 ms</p>
<p>--- ::1 ping statistics ---</p>
<p>2 packets transmitted, 2 received, 0% packet loss, time 999ms</p>
<p>rtt min/avg/max/mdev = 0.043/0.048/0.054/0.008 ms</p>
<p>&nbsp;<p>::1 — это сокращение от 0000:0000:0000:0000:0000:0000:0000:0001. Любая непрерывная последовательность нулей может быть заменена на пару двоеточий, а любая четвёрка, состоящая из нулей, может быть заменена на один ноль. Для нашего примера это 0.0.0.0.0.0.0.1.</p>
<p>Исследование сети</p>
<p>&nbsp;<p>Хотите узнать, есть ли кто-то в вашей сети, кто имеет поддержку IPv6? Легко!</p>
<p>$ ping6 -c4 -I eth0 ff02::1</p>
<p>PING FF02:0:0:0:0:0:0:1(ff02::1) from fe80::20d:b9ff:fe05:25b4 eth0: 56 data bytes</p>
<p>64 bytes from fe80::20d:b9ff:fe05:25b4: icmp_seq=1 ttl=64 time=0.301 ms</p>
<p>64 bytes from fe80::20b:6aff:feef:7e8d: icmp_seq=1 ttl=64 time=3.69 ms (DUP!)</p>
<p>64 bytes from fe80::221:97ff:feed:ef01: icmp_seq=1 ttl=64 time=8.91 ms (DUP!)</p>
<p>[snip duplicate lines]</p>
<p>--- FF02:0:0:0:0:0:0:1 ping statistics ---</p>
<p>4 packets transmitted, 4 received, +6 duplicates, 0% packet loss, time 3000ms</p>
<p>rtt min/avg/max/mdev = 0.254/1.698/8.911/2.593 ms</p>
<p>&nbsp;<p>Представленный в примере вывод команды ping6 говорит что да, есть два: fe80::20b:6aff:feef:7e8d и fe80::221:97ff:feed:ef01. Обратите внимание, что вы обязательно должнеы указать имя интерфейса программе ping6, даже если этот интерфейс в вашей системе один-единственный. ff02::1 — это сокращенный вариант адреса ff02:0:0:0:0:0:0:1, который является специальным мультикаст-адресом, предназначенным для отправки пакетов всем link-local хостам.</p>
<p>&nbsp;<p>Адреса link-local — это все адреса в диапазоне fe80::/10, который по смыслу эквивалентен диапазону 169.254.0.0/16 в IPv4. Любой адрес из этого диапазона предназначен для автоконфигурирования ОС и пакеты, отправленные с такого адреса не пропустит ни один маршрутизатор, ограничивая их существование в пределах сегмента локальной сети. Протокол IPv6 спроектирован так, что интерфейс обязан иметь link-local адрес, даже если у него есть другой</p>
<p>&nbsp;<p>После того, как ваш хост обменялся данными с другими хостами по IPv6, адреса последних попадут в таблицу окружения (neighbor table) IPv6 (это что-то вроде ARP-таблицы). Содержимое neighbor table вы можете просмотреть при помощи утилиты ip:</p>
<p>$ ip -6 neigh show</p>
<p>fe80::221:97ff:feed:ef01 dev eth0 lladdr 00:21:97:ed:ef:01 nud reachable</p>
<p>fe80::20b:6aff:feef:7e8d dev eth0 lladdr 00:0b:6a:ef:7e:8d nud reachable</p>
<p>&nbsp;<p>Здесь «nud reachable» означает «статус network unreachability detection установлен в состояние reachable», то есть сетевой хост доступен. Каждая запись в neighbor table временная и хранится в течение нескольких минут после последней сетевой активности в направлении хоста.</p>
<p>Использование сетевых имён</p>
<p>&nbsp;<p>Оставим пока «правильные» сисадминовские методы настройки соответствия имён хостов их IP-адресам, а сейчас воспользуемся старым добрым /etc/hosts. Представим, у вас есть три хоста в одном физическом сегменте сети, имеющие имена fatfreddy, phineas, и franklin. Создадим на каждом из хостов записи в /etc/hosts:</p>
<p>fe80::20b:6aff:feef:7e8d  fatfreddy</p>
<p>fe80::221:97ff:feed:ef01  phineas</p>
<p>fe80::3f1:4baf:a7dd:ba4f  franklin</p>
<p>&nbsp;<p>Теперь можно пинговать системы по имени:</p>
<p>$ ping6 -I eth0 phineas</p>
<p>PING phineas(phineas) from fe80::221:97ff:feed:ef01 eth0: 56 data bytes</p>
<p>64 bytes from phineas: icmp_seq=1 ttl=64 time=17.3 ms</p>
<p>SSH и SCP</p>
<p>&nbsp;<p>SSH и SCP умеют работать c IPv6. Внимание, при передаче параметров этим утилитам из командной строки, имеются определённые синтаксические особенности, так что будьте внимательны! Если у вас настроено корректное разрешение имён IPv6-хостов, то разницы при вызове утилит вообще никакой. Вы таким же образом можете подключаться к удалённой оболочке:</p>
<p>$ ssh user@remotehost</p>
<p>&nbsp;<p>и копировать файлы:</p>
<p>$ scp filename user@remotehost:/home/username/directory/.</p>
<p>&nbsp;<p>А вот в случае использования IPv6-адресов всё чуток сложнее. Установка SSH-сессии:</p>
<p>$ ssh phineas@fe80::221:97ff:feed:ef01%eth0</p>
<p>&nbsp;<p>И опять же, если вы используете link-local адрес, то вы должны указать имя интерфейса с которого будете осуществлять подключение. Как показано выше, делается это путём добавления знака процента и имени интерфейса. Вызов scp имеет ещё более дурацкий синтаксис:</p>
<p>$ scp test.txt phineas@\[fe80::221:97ff:feed:ef01%eth0\]:</p>
<p>phineas@fe80::221:97ff:feed: ef01%eth0's password:</p>
<p>test.txt 100%   19     0.0KB/s   00:00</p>
<p>&nbsp;<p>IPv6-адрес вместе именем интерфейса необходимо заключать в квадратные скобки, а квадратные скобки в свою очередь экранировать, чтобы оболочка не узрела в них спецсимволов.</p>
<p>Какой у меня IPv6-адрес?</p>
<p>&nbsp;<p>Команда 'ifconfig -a' выводит информацию обо всех сетевых интерфейсах, находящихся в системе: как о физических, так и о виртуальных. Получив информацию по конкретному интерфейсу вы можете воспользоваться grep, чтобы отфильтровать информацию об IPv6-адресе интерфейса:</p>
<p>$ ifconfig eth0 | grep &quot;inet6 addr:&quot;</p>
<p>          inet6 addr: fe80::20d:b9ff:fe05:25b4/64 Scope:Link</p>
<p>Интернет</p>
<p>&nbsp;<p>Работа в сегменте локальной сети — это, конечно, хорошо, но как обстоят дела в работой IPv6 в глобальной сети? Для того, чтобы воспользоваться IPv6 в интернет, ваш провайдер должен выдать вам «чистый» IPv6-адрес.  Таких провайдеров сегодня очень мало. Свою первую IPv6-сеть автор настроила в 2004 году и если бы вы сказали ей, что спустя семь лет ситуация с IPv6 останется почти такой же, она бы вам не поверила. Да, 2011-й в этом плане не очень-то отличается от 2004-го. Тем временем, вы можете воспользоваться IPv6-over-IPv4 tunnel broker-ами (как, впрочем, вы могли это сделать и в 2004-м!), такими как SixXS или Hurricane Electric.</p>
<p>&nbsp;<p>8 июня 2011 года — мировой день IPv6. В этот день Google, Comcast, Facebook, Yahoo!, Akamai и Limelight Networks, а также ещё некоторые провайдеры включат доступ к своим хостам по IPv6 на 24 часа. Убедитесь в том, что вы готовы принять участие в тестировании и узнайте больше на test-ipv6.com.</p>
<p>&nbsp;<p>Так же, как и в случае с IPv4, ваш провайдер должен выделить вам блок адресов IPv6. Адреса из этого блока являются глобальными адресами, находящимися в диапазоне 2000::/3. Давайте в качестве эксперимента попробуем присвоить какому-нибудь сетевому интерфейсу адрес из этого диапазона:</p>
<p># ip -6 addr add 2001::1/64 dev eth0</p>
<p>&nbsp;<p>Теперь взглянем, что у нас получилось:</p>
<p>$ ifconfig eth0 |grep &quot;inet6 addr:&quot;</p>
<p>          inet6 addr: 2001::1/64  Scope:Global</p>
<p>          inet6 addr: fe80::20b:6aff:feef:7e8d/64 Scope:Link</p>
<p>&nbsp;<p>Удалить назначенный адрес можно при помощи всё той же утилиты ip:</p>
<p># ip -6 addr del 2001::1/64 dev eth0</p>
<p>&nbsp;<p>В реальной жизни вам будут выделять большой блок адресов, например 256 или больше, так что вам нужно будет настроить сервер для их автоматической раздачи вашим хостам. В следующей части статьи мы с вами рассмотрим, как это делается. Также рассмотрим, как необходимо настроить файрволл и службу имён для работы с IPv6.</p>
<p>&nbsp;<p>Источник: Linux.Com </p>

</p></body></html>
