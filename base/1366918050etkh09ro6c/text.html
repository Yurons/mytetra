<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">
<p><span style="font-family:Courier New,courier;"><span style="font-size:9pt;"><a href="http://www.ibm.com/developerworks/ru/library/l-awk1/">Common threads: Часть 1. Awk в примерах</a> </span></span></p>
<p>&nbsp;<p>Введение в замечательный язык со странным именем</p>
<p>Даниэль Роббинс, президент/исполнительный директор, Gentoo Technologies, Inc.</p>
<p>&nbsp;<p>&nbsp;<p>Описание:  Awk — чудесный язык с очень странным именем. В этой первой статье серии, состоящей из трёх частей, Даниэль Роббинс дает краткое введение в основы программирования на awk. В следующих статьях серии будут рассмотрены более продвинутые темы, и в завершение будет создано серьёзное демонстрационное приложение на awk из реальной практики.</p>
<p>&nbsp;<p>Теги этой статьи:  awk</p>
<p>&nbsp;<p>Пометить это!</p>
<p>&nbsp;<p>&nbsp;<p>Дата:  29.01.2009 </p>
<p>Уровень сложности:  простой </p>
<p>Активность:  33435 просмотров </p>
<p>Комментарии:   0 (Посмотреть | Добавить комментарий - Войти) </p>
<p> Средний показатель рейтинга (187 голоса)</p>
<p>Оценить эту статью</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В защиту awk</p>
<p>&nbsp;<p>В этой серии статей я собираюсь сделать из читателя искусного программиста на awk. Я согласен, что у awk не самое приятное и модное имя, а GNU-версия awk, названная gawk, звучит откровенно странно. Незнакомые с этим языком программисты, услышав его название, возможно, представят себе мешанину древнего и устаревшего кода, способного довести до умопомрачения даже самого знающего специалиста по UNIX (заставив его восклицать &quot;kill -9!&quot; и беспрестанно бегать за кофе). </p>
<p>&nbsp;<p>Да, у awk отнюдь не замечательное имя. Но это замечательный язык. Awk создан для обработки текста и создания отчетов, но у него много хорошо проработанных функций, дающих возможность серьезного программирования. При этом, в отличие от некоторых других языков, синтаксис awk привычен и заимствует лучшее из таких языков, как C, python и bash (хотя формально awk был создан до python и bash). Awk — один из тех языков, которые, будучи один раз выучены, становятся ключевой частью стратегического арсенала программиста. </p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Первый шаг в awk </p>
<p>&nbsp;<p>Давайте начнем и попробуем поэкспериментировать с awk, чтобы увидеть, как он работает. В командной строке введем следующую команду: $ awk '{ print }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В результате должно быть показано содержимое файла /etc/passwd. Теперь — объяснение того, что делал awk. Вызывая awk, мы указали /etc/passwd в качестве входного файла. Когда мы запустили awk, он обработал команду print для каждой строки в /etc/passwd по порядку. Весь вывод отправлен в stdout, и мы получили результат, идентичный результату команды cat /etc/passwd. Теперь объясним блок { print }. В awk фигурные скобки используются для группирования блоков текста, как в C. В нашем блоке текста есть лишь одна команда print. В awk команда print без дополнительных параметров печатает все содержимое текущей строки. </p>
<p>&nbsp;<p>Вот еще один пример программы на awk, которая делает то же самое: $ awk '{ print $0 }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В awk переменная $0 представляет всю текущую строку, поэтому print и print $0 делают в точности одно и то же. Если угодно, можно создать программу на awk, которая будет выводить данные, совершенно не связанные с входными данными. Вот пример: $ awk '{ print &quot;&quot; }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>При передаче строки &quot;&quot; команде print она всегда печатает пустую строку. Если протестировать этот скрипт, обнаружится, что awk выводит одну пустую строку на каждую строку в файле /etc/passwd. Это опять-таки происходит потому, что awk исполняет скрипт для каждой строки во входном файле. Вот еще один пример: $ awk '{ print &quot;hiya&quot; }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Если запустить этот скрипт, он заполнит экран словами «ура». :) </p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Множественные поля </p>
<p>&nbsp;<p>Awk хорошо подходит для обработки текста, разбитого на множество логических полей, и дает возможность без усилий обращаться к каждому отдельному полю из awk-скрипта. Следующий скрипт распечатает список всех учетных записей в системе: $ awk -F&quot;:&quot; '{ print $1 }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В вызове awk в вышеприведенном примере параметр –F задает &quot;:&quot; в качестве разделителя полей. Обрабатывая команду print $1, awk выводит первое поле, встреченное в каждой строке входного файла. Вот еще один пример: $ awk -F&quot;:&quot; '{ print $1 $3 }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Вот фрагмент из вывода на экран этого скрипта:halt7 </p>
<p>operator11 </p>
<p>root0 </p>
<p>shutdown6 </p>
<p>sync5 </p>
<p>bin1 </p>
<p>....etc. </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Как видим, awk выводит первое и третье поля файла /etc/passwd, которые представляют собой соответственно поля имени пользователя и uid. При этом, хотя скрипт и работает, он не совершенен — нет пробелов между двумя выходными полями! Те, кто привык программировать в bash или python, возможно ожидали, что команда print $1 $3 вставит пробел между этими двумя полями. Однако когда в программе на awk две строки оказываются рядом друг с другом, awk сцепляет их без добавления между ними пробела. Следующая команда вставит пробел между полями: $ awk -F&quot;:&quot; '{ print $1 &quot; &quot; $3 }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Когда print вызывается таким способом, он последовательно соединяет $1, &quot; &quot; и $3, создавая удобочитаемый вывод на экране. Конечно, мы можем также вставить метки полей, если нужно: $ awk -F&quot;:&quot; '{ print &quot;username: &quot; $1 &quot;\t\tuid:&quot; $3&quot; }' /etc/passwd </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В результате получаем такой вывод:username: halt     uid:7 </p>
<p>username: operator uid:11 </p>
<p>username: root     uid:0 </p>
<p>username: shutdown uid:6 </p>
<p>username: sync     uid:5 </p>
<p>username: bin      uid:1 </p>
<p>....etc. </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Внешние скрипты</p>
<p>&nbsp;<p>Передача скриптов в awk в виде аргументов командной строки может быть удобной для небольших однострочных текстов, но когда дело доходит до сложных многострочных программ, определенно будет лучше составить скрипт в виде внешнего файла. После этого можно указать awk этот скриптовый файл с помощью параметра -f:$ awk -f myscript.awk myfile.in </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Размещение скриптов в отдельных текстовых файлах также позволяет воспользоваться дополнительными преимуществами awk. Например, следующий многострочный скрипт делает то же самое, что и один из наших предыдущих однострочных - распечатывает первое поле каждой строки из /etc/passwd: BEGIN { </p>
<p>        FS=&quot;:&quot; </p>
<p>} </p>
<p>{ print $1 } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Разница между этими двумя методами состоит в том, как мы задаем разделитель полей. В этом скрипте разделитель полей указывается внутри самой программы (установкой переменной FS), тогда как в нашем предыдущем примере FS настраивается путем передачи awk параметра -F&quot;:&quot; в командной строке. Обычно лучше всего задавать разделитель полей внутри самого скрипта, просто потому, что тогда не потребуется запоминать ещё один аргумент командной строки. Позже в этой статье мы рассмотрим переменную FS более подробно.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Блоки BEGIN и END</p>
<p>&nbsp;<p>Обычно awk выполняет каждый блок в тексте скрипта один раз для каждой входной строки. Однако в программировании часто встречаются ситуации, когда требуется выполнить код инициализации перед тем, как awk начнет обрабатывать текст из входного файла. Для таких случаев awk дает возможность определять блок BEGIN. Мы использовали блок BEGIN в предыдущем примере. Поскольку блок BEGIN обрабатывается до того, как awk начинает обрабатывать входной файл, это отличное место для инициализации переменной FS (разделитель полей), вывода заголовка или инициализации других глобальных переменных, которые будут позже использоваться в программе.</p>
<p>&nbsp;<p>Awk также предоставляет еще один специальный блок, называемый блоком END. Awk выполняет этот блок после того, как все строки во входном файле были обработаны. Обычно блок END используется для выполнения заключительных вычислений или вывода итогов, которые должны появиться в конце выходного потока. </p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Регулярные выражения и блоки</p>
<p>&nbsp;<p>Awk позволяет использовать регулярные выражения для избирательного выполнения отдельных блоков программы в зависимости от того, совпадает или нет регулярное выражение с текущей строкой. Вот пример скрипта, который выводит только те строки, которые содержат символьную последовательность foo:/foo/ { print } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Конечно, можно использовать более сложные регулярные выражения. Вот скрипт, который будет выводить только строки, содержащие число с плавающей точкой: /[0-9]+\.[0-9]*/ { print } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Выражения и блоки </p>
<p>&nbsp;<p>Есть много других способов избирательно выполнять блок программы. Мы можем поместить перед блоком программы любое булево выражение для управления исполнением этого блока. Awk будет выполнять блок программы, только если предыдущее булево выражение равно true. Следующий пример скрипта будет выводить третье поле всех строк, в которых первое поле равно fred. Если первое поле текущей строки не равно fred, awk продолжит обработку файла и не выполнит оператор print для текущей строки: :$1 == &quot;fred&quot; { print $3 }</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Awk предлагает полный набор операторов сравнения, в том числе обычные &quot;==&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot; и &quot;!=&quot;. Кроме того, awk предоставляет операторы &quot;~&quot; и &quot;!~&quot;, которые означают &quot;совпадает&quot; и &quot;не совпадает&quot;. При их использовании переменная помещается слева от оператора, а регулярное выражение — справа от него. Вот пример, где выводится только третье поле строки, если пятое поле той же строки содержит символьную последовательность root:$5 ~ /root/ { print $3 } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Условные операторы </p>
<p>&nbsp;<p>Awk предоставляет также очень приятные C-подобные операторы if. При желании можно переписать предыдущий скрипт с использованием if:{ </p>
<p>  if ( $5 ~ /root/ ) { </p>
<p>          print $3 </p>
<p>  } </p>
<p>} </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Оба скрипта работают идентично. В первом примере булево выражение находится вне блока, в то время как во втором примере блок выполняется для каждой входной строки, и мы избирательно выполняем команду печати, используя оператор if Оба метода работают, и выбрать можно тот, который наилучшим образом объединяется с другими частями скрипта. </p>
<p>&nbsp;<p>Вот более сложный пример оператора if в awk. Как можно видеть, даже в случае сложных вложенных условных выражений операторы if выглядят идентично их аналогам в C:{ </p>
<p>  if ( $1 == &quot;foo&quot; ) { </p>
<p>           if ( $2 == &quot;foo&quot; ) { </p>
<p>                    print &quot;uno&quot; </p>
<p>           } else { </p>
<p>                    print &quot;one&quot; </p>
<p>           } </p>
<p>  } else if ($1 == &quot;bar&quot; ) { </p>
<p>           print &quot;two&quot; </p>
<p>  } else { </p>
<p>           print &quot;three&quot; </p>
<p>  } </p>
<p>} </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Используя операторы if, мы можем преобразовать этот код: ! /matchme/ { print $1 $3 $4 }</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>в такой: { </p>
<p>  if ( $0 !~ /matchme/ ) { </p>
<p>          print $1 $3 $4 </p>
<p>  } </p>
<p>} </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Оба скрипта распечатают только те строки, которые не содержат символьную последовательность matchme. И в этом случае тоже можно выбрать метод, который лучше работает в конкретной программе. Они оба делают одно и то же.</p>
<p>&nbsp;<p>Awk также дает возможность использовать булевы операторы &quot;||&quot; (&quot;логическое ИЛИ&quot;) и &quot;&amp;&amp;&quot;(&quot;логическое И&quot;), что позволяет создавать более сложные булевы выражения: ( $1 == &quot;foo&quot; ) &amp;&amp; ( $2 == &quot;bar&quot; ) { print } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Этот пример выведет только те строки, в которых первое поле равно foo и второе поле равно bar.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Числовые переменные! </p>
<p>&nbsp;<p>До сих пор мы распечатывали либо строковые переменные, либо целые строки, либо конкретные поля. Однако awk также дает нам возможность выполнять сравнение как целых чисел, так и чисел с плавающей запятой. Используя математические выражения, очень легко написать скрипт, который считает число пустых строк в файле. Вот один такой скрипт: BEGIN { x=0 } </p>
<p>/^$/  { x=x+1 } </p>
<p>END   { print &quot;Найдено &quot; x &quot; пустых строк. :)&quot;</p>
<p> } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В блоке BEGIN мы инициализируем нашу целочисленную переменную x значением ноль. Затем каждый раз, когда awk встречает пустую строку, он будет выполнять оператор x=x+1, увеличивая xна 1. После того как все строки будут обработаны, будет выполнен блок END, и awk выведет конечный итог, указав число найденных пустых строк.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Строчные переменные </p>
<p>&nbsp;<p>Одной из приятных особенностей переменных awk является то, что они &quot;простые и строчные.&quot; Я называю переменные awk &quot;строчными&quot;, потому что все переменные awk внутри хранятся как строки. В то же время переменные awk &quot;простые&quot;, потому что с переменной можно производить математические операции, и если она содержит правильную числовую строку, awk автоматически позаботится о преобразовании строки в число. Чтобы понять, что я имею в виду, взглянем на этот пример:x=&quot;1.01&quot; </p>
<p># Мы сделали так, что x содержит *строку* &quot;1.01&quot; </p>
<p>x=x+1 </p>
<p># Мы только что прибавили 1 к *строке* </p>
<p>print x </p>
<p># Это, кстати, комментарий :) </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Awk выведет:2.01</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Любопытно! Хотя мы присвоили переменной x строковое значение 1.01, мы все же смогли прибавить к ней единицу. Нам бы не удалось сделать это в bash или python. Прежде всего, bash не поддерживает арифметику с плавающей запятой. И, хотя в bash есть &quot;строчные&quot; переменные, они не являются &quot;простыми&quot;; для выполнения любых математических операций bash требует, чтобы мы заключили наши вычисления в уродливые конструкции $( ) . Если бы мы использовали python, нам бы потребовалось явно преобразовать нашу строку 1.01 в значение с плавающей запятой, прежде чем выполнять какие-либо расчеты с ней. Хоть это и не трудно, но это все-таки дополнительный шаг. В случае с awk все это делается автоматически, и это делает наш код красивым и чистым. Если бы нам потребовалось возвести первое поле каждой входной строки в квадрат и прибавить к нему единицу, мы бы воспользовались таким скриптом:{ print ($1^2)+1 } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Если немного поэкспериментировать, то можно обнаружить, что если в какой-то переменной не содержится правильного числа, awk при вычислении математического выражения будет обращаться с этой переменной как с числовым нулем.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Множество операторов </p>
<p>&nbsp;<p>Еще одна приятная особенность awk — это полный комплект математических операторов. Кроме стандартных сложения, вычитания, умножения и деления, awk дает нам возможность использовать ранее продемонстрированный оператор показателя степени &quot;^&quot;, оператор остатка целочисленного деления &quot;%&quot; и множество других удобных операторов присваивания, заимствованных из C.</p>
<p>&nbsp;<p>К ним относятся пред- и постинкрементные/декрементные операторы присваивания ( i++, --foo ), операторы присваивания со сложением/вычитанием/умножением/делением (a+=3, b*=2, c/=2.2, d-=6.2). Но это ещё не все — мы имеем также удобные операторы присваивания с вычислением остатка целочисленного деления и возведением в степень ( a^=2, b%=4 ). </p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Разделители полей </p>
<p>&nbsp;<p>В awk есть свой собственный комплект специальных переменных. Некоторые из них дают возможность тонкой настройки работы awk, а другие содержат ценную информацию о вводе. Мы уже затронули одну из этих специальных переменных, FS. Как упоминалось ранее, эта переменная позволяет задать последовательность символов, которую awk будет считать разделителем полей. Когда мы использовали в качестве ввода /etc/passwd, FS была установлена в &quot;:&quot;. Это оказалось достаточно, но FS предоставляет нам еще большую гибкость. </p>
<p>&nbsp;<p>Значение переменной FS не обязано быть одним символом; ей может быть присвоено регулярное выражение, задающее символьный шаблон любой длины. Если производится обработка полей, разделенных одним или несколькими символами табуляции, то FS нужно настроить таким образом: FS=&quot;\t+&quot; </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Выше мы использовали специальный символ регулярных выражений &quot;+&quot;, который означает &quot;одно или несколько вхождений предыдущего символа&quot;. </p>
<p>&nbsp;<p>Если поля разделены пустой областью (один или несколько пробелов или символов табуляции), возможно, вам захочется установить для FS следующее регулярное выражение:FS=&quot;[[:space:]+]&quot; </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Хотя такая настройка сработает, в ней нет необходимости. Почему? Потому что по умолчанию значение FS равно одному символу пробела, который awk интерпретирует как &quot;один или несколько пробелов или символов табуляции&quot;. В нашем конкретном примере значение FS по умолчанию именно такое, как нам было нужно!</p>
<p>&nbsp;<p>Со сложными регулярными выражениями также не возникает проблем. Даже если записи разделены словом &quot;foo&quot;, за которым следуют три цифры, следующее регулярное выражение позволит правильно разобрать данные: FS=&quot;foo[0-9][0-9][0-9]&quot; </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Число полей</p>
<p>&nbsp;<p>Следующие две переменные, которые мы собираемся рассмотреть, обычно не предназначены для записи в них, а используются для чтения и получения полезной информации о вводе. Первая из них — переменная NF, называемая также &quot;число полей&quot;. Awk автоматически устанавливает значение этой переменной равным числу полей в текущей записи. Можно использовать переменную NF для отображения только определенных входных строк: NF == 3 { print &quot;в этой записи три поля: &quot; $0 } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Конечно, переменную NF можно использовать и в условных операторах, например:{ </p>
<p>  if ( NF &gt; 2 ) { </p>
<p>          print $1 &quot; &quot; $2 &quot;:&quot; $3 </p>
<p>  } </p>
<p>} </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Номер записи</p>
<p>&nbsp;<p>Еще одна удобная переменная - номер записи (NR). Она всегда содержит номер текущей записи (awk считает первую запись записью номер 1). До сих пор мы имели дело с входными файлами, которые содержали одну запись на строку. В таких ситуациях NR также сообщит номер текущей строки. Однако когда мы начнем обрабатывать многострочные записи в следующих статьях этой серии, это уже будет не так, поэтому нужно проявлять осторожность! NR можно использовать подобно переменной NF для вывода только определенных строк ввода:(NR &lt; 10 ) || (NR &gt; 100) { print &quot;Мы на записи номер 1-9 или 101 и более&quot; } </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Еще один пример:{ </p>
<p>  #skip header </p>
<p>  if ( NR &gt; 10 ) { </p>
<p>          print &quot;вот теперь пошла настоящая информация!&quot; </p>
<p>  } </p>
<p>} </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Awk предоставляет дополнительные переменные, которые могут быть использованы для различных целей. Мы рассмотрим эти переменные в следующих статьях. Мы подошли к концу нашего начального исследования awk. В следующих статьях серии я покажу более сложную функциональность awk, и мы закончим эту серию awk-приложением из реальной практики. А пока, если хочется узнать больше, можно просмотреть ресурсы, перечисленные ниже.<span style="font-family:Sans Serif;"> </span></p>

</p></body></html>
