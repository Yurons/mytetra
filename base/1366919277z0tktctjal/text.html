<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:10pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">
<p><span style="font-family:Courier New,courier;"><span style="font-size:9pt;"><a href="http://www.ibm.com/developerworks/ru/library/au-badunixhabits/">Советы по UNIX: Осваиваем 10 полезных приемов работы в UNIX</a> </span></span></p>
<p>&nbsp;<p>Откажитесь от неудачных приемов работы в UNIX</p>
<p>Майкл Штатц, автор, консультант</p>
<p>&nbsp;<p>&nbsp;<p>Описание:  Освоив 10 полезных приемов, вы повысите эффективность работы с командной строкой UNIX и сможете избежать плохих моделей организации работы.</p>
<p>&nbsp;<p>Теги этой статьи:  cat, ed, sed</p>
<p>&nbsp;<p>Пометить это!</p>
<p>&nbsp;<p>&nbsp;<p>Дата:  18.04.2007 </p>
<p>Уровень сложности:  средний </p>
<p>Активность:  6344 просмотров </p>
<p>Комментарии:   1 (Посмотреть | Добавить комментарий - Войти) </p>
<p> Средний показатель рейтинга (24 голоса)</p>
<p>Оценить эту статью</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Введение</p>
<p>&nbsp;<p>Часто используя какую-либо систему, мы привыкаем к некоторым шаблонам работы. Но не всегда эти шаблоны оказываются оптимальными. Иногда мы даже приобретаем плохие привычки, которые приводят к беспорядку и неуклюжести в работе. Один из наилучших путей исправления таких недостатков – выработка привычки использовать хорошие приемы, которые препятствуют беспорядку. Эта статья предлагает 10 методов работы с командной строкой UNIX, достойных стать привычками, которые помогут вам избежать много общих недостатков и повысить эффективность работы. Подробное описание каждого из методов приведено после списка. </p>
<p>&nbsp;<p>Усвоим 10 хороших привычек</p>
<p>&nbsp;<p>Десять хороших методов, к которым стоит привыкнуть:</p>
<p>Создавайте деревья каталогов одной командой.</p>
<p>Изменяйте пути; не переносите архив.</p>
<p>Объединяйте ваши команды с операторами управления.</p>
<p>Будьте внимательны при использовании кавычек в работе с переменными.</p>
<p>Используйте управляющую последовательность символов для ввода длинной строки.</p>
<p>Объединяйте команды в список.</p>
<p>Используйте xargs для вывода find .</p>
<p>Знайте, когда использовать grep для подсчета - а когда от него лучше отказаться.</p>
<p>Сравнивайте определенные поля при выводе, не только строки.</p>
<p>Не используйте передачу вывода cat .</p>
<p>&nbsp;<p>Создавайте деревья каталогов одной командой</p>
<p>&nbsp;<p>Листинг 1 иллюстрирует один из наиболее распространенных неудачных методов работы в UNIX: пошаговое определение дерева каталогов.</p>
<p>&nbsp;<p>Листинг 1. Пример плохого метода работы #1: Пошаговое определение дерева каталогов                </p>
<p>~ $ mkdir tmp</p>
<p>~ $ cd tmp</p>
<p>~/tmp $ mkdir a</p>
<p>~/tmp $ cd a</p>
<p>~/tmp/a $ mkdir b</p>
<p>~/tmp/a $ cd b</p>
<p>~/tmp/a/b/ $ mkdir c</p>
<p>~/tmp/a/b/ $ cd c</p>
<p>~/tmp/a/b/c $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Намного быстрее использовать опцию -p mkdir и создавать все родительские и дочерние каталоги одной командой. Но даже администраторы, которые знают об этой опции, до сих пор работают пошагово, создавая в командной строке каждый подкаталог в отдельности. Берегите свое время - привыкайте к хорошим методам:</p>
<p>&nbsp;<p>Листинг 2. Пример хорошего метода работы #1: Определение дерева каталогов одной командой                </p>
<p>~ $ mkdir -p tmp/a/b/c</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Вы можете использовать эту опцию, чтобы создать не только простую иерархию, но и сложные деревья каталогов, которые очень удобно использовать в скриптах. Например:</p>
<p>&nbsp;<p>Листинг 3. Еще один пример хорошего метода работы #1: Определение сложного дерева каталогов одной командой                </p>
<p>~ $ mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Раньше была только одна причина пошагово определять дерево каталогов - реализация mkdir не поддерживала эту опцию, но теперь это не актуально для большинства систем. IBM, AIX, mkdir, GNU mkdir и остальные системы, соответствующие единой спецификации UNIX, сейчас имеют эту опцию.</p>
<p>&nbsp;<p>Для немногих систем, в которых отсутствует эта возможность, следует использовать скрипт mkdirhier (см. Ресурсы), который служит оболочкой для mkdir и выполняет ту же функцию.~ $ mkdirhier project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Изменяйте пути; не переносите архив</p>
<p>&nbsp;<p>Еще один неудачный метод работы - это перемещение архивного файла .tar в определенный каталог, если вам захотелось извлечь архив именно в этот каталог. Вам не стоит так делать. Вы можете распаковать любой архивный файл .tar в любой каталог - для этого предназначена опция -C. Используйте опцию -C, чтобы указать каталог для распаковки:</p>
<p>&nbsp;<p>Листинг 4: Пример хорошего метода работы #2: Использование опции -C для распаковки архивного файла .tar                </p>
<p>~ $ tar xvf -C tmp/a/b/c newarc.tar.gz</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Использование опции -C предпочтительнее, чем перемещение архивного файла в нужный вам каталог, смена каталога и извлечение содержимого файла – особенно, если сам архивный файл находится где-то в другом месте.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Объединяйте ваши команды с операторами управления</p>
<p>&nbsp;<p>Вы, вероятно, уже знаете, что в большинстве оболочек вы можете комбинировать команды в одной командной строке с помощью использования точки с запятой (;) между ними. Точка с запятой - это управляющий оператор оболочки, и хотя он предназначен, для того чтобы связывать множественные отдельные команды в единую командную строку, его применение не всегда возможно. Например, предположим, что вы используете точку с запятой для объединения двух команд, в которых выполнение второй команды всецело зависит от успешного окончания первой. Если первая команда не выполняется так, как вы ожидаете, вторая команда все же запускается - и терпит неудачу. Вместо этого, используйте более подходящий оператор управления (некоторые описаны в данной статье). Если ваша оболочка их поддерживает, к ним стоит привыкнуть.</p>
<p>&nbsp;<p>Запуск команды только в том случае, если другая команда возвратила нулевое значение</p>
<p>&nbsp;<p>Используйте оператор управления &amp;&amp; для объединения двух команд таким образом, что вторая команда будет выполняться, только если первая возвратила нулевое значение. Другими словами, если первая команда выполняется успешно, вторая команда тоже запускается. Если первая команда не выполняется, то вторая команда не запускается совсем. Например:</p>
<p>&nbsp;<p>Листинг 5. Пример хорошего метода работы #3: Объединяйте команды с операторами управления                </p>
<p>~ $ cd tmp/a/b/c &amp;&amp; tar xvf ~/archive.tar</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В этом примере содержимое архива извлекается в каталог ~/tmp/a/b/c, если этот каталог существует. Если каталог не существует, команда tar не запустится и из архива ничего не будет извлечено.</p>
<p>&nbsp;<p>Запуск команды только в том случае, если другая команда возвратила ненулевое значение</p>
<p>&nbsp;<p>Точно так же оператор управления || разделяет две команды и запускает вторую команду, только если первая команда возвратила ненулевое значение. Другими словами, если первая команда была успешной, вторая команда не запустится. Если первая команда завершилась с ошибкой, то вторая запустится. Этот оператор часто применяется для тестирования с условием: существует ли заданный каталог, если нет, то он его создает:</p>
<p>&nbsp;<p>Листинг 6. Еще один пример хорошего метода работы #3: Объединяйте команды с операторами управления                </p>
<p>~ $ cd tmp/a/b/c || mkdir -p tmp/a/b/c</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Также можно комбинировать операторы управления, описанные в этом разделе. Каждый из них относится к последней запускавшейся команде:</p>
<p>&nbsp;<p>Листинг 7. Комбинированный пример хорошего метода работы #3: Объединение команд с операторами управления                </p>
<p>~ $ cd tmp/a/b/c || mkdir -p tmp/a/b/c &amp;&amp; tar xvf -C tmp/a/b/c ~/archive.tar</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Будьте внимательны при использовании кавычек в работе с переменными</p>
<p>&nbsp;<p>Всегда будьте осторожны с расширением оболочки и именами переменных. Вообще-то, это хорошая идея - брать обращения к переменным в двойные кавычки, только если нету особых причин не делать этого. Аналогично, если непосредственно за именем переменной следует буквенно-цифровой текст, имя переменной следует заключить в фигурные скобки ({}), чтобы отличать ее от окружающего текста. Иначе оболочка интерпретирует замыкающий текст как часть имени переменной - и наиболее вероятный результат - нулевой код возврата. В Листинге 8 приведены примеры вариантов использования кавычек с именами переменных и получаемые результаты.</p>
<p>&nbsp;<p>Листинг 8. Пример хорошего метода работы #4: Использование (и не использование) кавычек в работе с переменными                </p>
<p>~ $ ls tmp/</p>
<p>a b</p>
<p>~ $ VAR=&quot;tmp/*&quot;</p>
<p>~ $ echo $VAR</p>
<p>tmp/a tmp/b</p>
<p>~ $ echo &quot;$VAR&quot;</p>
<p>tmp/*</p>
<p>~ $ echo $VARa</p>
<p>&nbsp;<p>~ $ echo &quot;$VARa&quot;</p>
<p>&nbsp;<p>~ $ echo &quot;${VAR}a&quot;</p>
<p>tmp/*a</p>
<p>~ $ echo ${VAR}a</p>
<p>tmp/a</p>
<p>~ $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Используйте управляющую последовательность символов для ввода длинной строки</p>
<p>&nbsp;<p>Вы, вероятно, встречали примеры кода, в котором обратный слэш (\) продолжает длинную строку, и вы знаете, что большинство оболочек трактует то, что вы печатаете в последующих строках, присоединенных с помощью обратного слэша, как одну длинную строку. Тем не менее, вы можете получить больше пользы от этой функции в командной строке, используя ее чаще. Обратный слэш особенно удобен, если ваш терминал не справляется должным образом с обработкой многострочных переносов или когда командная строка короче, чем обычно (к примеру, когда у вас в командной строке указан длинный путь). Обратный слэш также полезен для выделения смысловых частей длинной строки, как в следующем примере:</p>
<p>&nbsp;<p>Листинг 9. Пример хорошего метода работы #5: Использование обратного слэша в длинных строках                </p>
<p>~ $ cd tmp/a/b/c || \</p>
<p>&gt; mkdir -p tmp/a/b/c &amp;&amp; \</p>
<p>&gt; tar xvf -C tmp/a/b/c ~/archive.tar</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В качестве альтернативы приведена еще одна конфигурация, которая также работает:</p>
<p>&nbsp;<p>Листинг 10. Альтернативный пример хорошего метода работы #5: Использование обратного слэша в длинных строках                </p>
<p>~ $ cd tmp/a/b/c \</p>
<p>&gt;                 || \</p>
<p>&gt; mkdir -p tmp/a/b/c \</p>
<p>&gt;                    &amp;&amp; \</p>
<p>&gt; tar xvf -C tmp/a/b/c ~/archive.tar</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Когда вы разделяете строку на множество строк, оболочка всегда рассматривает ее как одну целую, удаляя из полученной длинной строки все обратные слэши и лишние пробелы.</p>
<p>&nbsp;<p>Примечание: В большинстве оболочек, когда вы нажимаете стрелку вверх, вся мульти-строка изображается в виде единой длинной строки.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Объединяйте команды в список</p>
<p>&nbsp;<p>Большинство оболочек позволяет объединять наборы команд в список; таким образом, вы можете организовать конвейерную передачу результатов работы от одной команды к другой или перенаправить их другим способом . Вы можете, как правило, сделать это с помощью запуска списка команд в дополнительной или в текущей оболочке.</p>
<p>&nbsp;<p>Запуск списка команд в дополнительной оболочке</p>
<p>&nbsp;<p>Используйте круглые скобки для заключения списка команд в одну группу. Это позволяет запустить команды в дополнительной оболочке и перенаправить или иным способом собрать результаты их работы, как показано в следующем примере:</p>
<p>&nbsp;<p>Листинг 11. Пример хорошего метода работы #6: Запуск списка команд в дополнительной оболочке                </p>
<p>~ $ ( cd tmp/a/b/c/ || mkdir -p tmp/a/b/c &amp;&amp; \</p>
<p>&gt; VAR=$PWD; cd ~; tar xvf -C $VAR archive.tar ) \</p>
<p>&gt; | mailx admin -S &quot;Archive contents&quot;</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В этом примере содержимое архива извлекается в каталог tmp/a/b/c, в то время как вывод сгруппированных команд, включая список извлеченных файлов, отправляется по почте на адрес admin. </p>
<p>&nbsp;<p>Использование дополнительных оболочек удобно в тех случаях, когда вы переопределяете переменные среды в списке команд и не хотите принимать эти изменения в своей текущей оболочке.</p>
<p>&nbsp;<p>Запуск списка команд в текущей оболочке</p>
<p>&nbsp;<p> Используйте фигурные скобки ({}) для заключения списка команд для запуска в текущей оболочке. Убедитесь, что вы добавили пробелы между скобками и командами, т.к. в противном случае оболочка может неправильно интерпретировать скобки.. Также убедитесь, что после последней команды в списке стоит точка с запятой (;), как в следующем примере:</p>
<p>&nbsp;<p>Листинг 12. Еще один пример хорошего метода работы #6: Запуск списка команд в текущей оболочке                </p>
<p>~ $ { cp ${VAR}a . &amp;&amp; chown -R guest.guest a &amp;&amp; \</p>
<p>&gt; tar cvf newarchive.tar a; } | mailx admin -S &quot;New archive&quot;</p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Применяйте xargs к результатам работы поиска find </p>
<p>&nbsp;<p>Используйте команду xargs в качестве фильтра для работы со списком файлов, полученным в результате выполнения поиска командой find. Обычно команда find выдает список файлов, соответствующий некоторому критерию. Этот список передается к xargs, которая выполняет другие операции, используя список файлов в качестве аргументов, как в следующем примере:</p>
<p>&nbsp;<p>Листинг 13. Пример классического применения команды xargs                 </p>
<p>~ $ find some-file-criteria some-file-path | \</p>
<p>&gt; xargs some-great-command-that-needs-filename-arguments</p>
<p>                </p>
<p>            </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Тем не менее, не думайте, что xargs - это только дополнение к find; это один из тех инструментов, привыкнув к которому, хочешь работать с ним постоянно, например, в следующих случаях: </p>
<p>&nbsp;<p>Передача списка с разделяющими пробелами</p>
<p>&nbsp;<p>В этой простой иллюстрации xargs похож на фильтр, который берет на вход список (каждый элемент на отдельной строке) и ставит его элементы на одну строку, разделяя их пробелами:</p>
<p>&nbsp;<p>Листинг 14. Пример результата работы команды xargs                 </p>
<p>~ $ xargs</p>
<p>                a</p>
<p>                b</p>
<p>                c</p>
<p>                </p>
<p>                    Control-D</p>
<p>                </p>
<p>a b c</p>
<p>~ $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Вы можете посылать вывод любого инструмента, который выводит имена файлов, через xargs, чтобы получить список аргументов для некоторых других инструментов, которые рассматривают имена файла как аргумент, как в следующем примере:</p>
<p>&nbsp;<p>Листинг 15. Пример использования команды xargs                 </p>
<p>~/tmp $ ls -1 | xargs</p>
<p>December_Report.pdf README a archive.tar mkdirhier.sh</p>
<p>~/tmp $ ls -1 | xargs file</p>
<p>December_Report.pdf: PDF document, version 1.3</p>
<p>README: ASCII text</p>
<p>a: directory</p>
<p>archive.tar: POSIX tar archive</p>
<p>mkdirhier.sh: Bourne shell script text executable</p>
<p>~/tmp $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Команда xargs полезна не только для передачи имен файлов. Используйте ее каждый раз, когда вам надо отфильтровать текст в одну строку:</p>
<p>&nbsp;<p>Листинг 16. Пример хорошего метода работы #7: Использование инструмента xargs для фильтрации текста в одну строку                </p>
<p>~/tmp $ ls -l | xargs</p>
<p>-rw-r--r-- 7 joe joe 12043 Jan 27 20:36 December_Report.pdf -rw-r--r-- 1 \</p>
<p>root root 238 Dec 03 08:19 README drwxr-xr-x 38 joe joe 354082 Nov 02 \</p>
<p>16:07 a -rw-r--r-- 3 joe joe 5096 Dec 14 14:26 archive.tar -rwxr-xr-x 1 \</p>
<p>joe joe 3239 Sep 30 12:40 mkdirhier.sh</p>
<p>~/tmp $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Будьте осторожны, используя xargs </p>
<p>&nbsp;<p>Формально, бывают редкие случаи, когда использование xargs может вызвать затруднение. По умолчанию, символ конца файла - это нижнее подчеркивание (_); если этот символ был передан на вход, как единственный аргумент, все после него будет игнорироваться. Как меру предосторожности используйте флаг -e, который без аргументов отключает символ конца файла.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Знайте, когда использовать grep для подсчета - а когда от него лучше отказаться</p>
<p>&nbsp;<p>Избегайте использовать после grep команду wc -l для подсчета количества полученных строк. Опция -c в grep позволяет подсчитать количество строк, которые соответствуют заданным шаблонам и в целом работает быстрее, чем комбинация &quot;wc после grep&quot;, как в следующем примере:</p>
<p>&nbsp;<p>Листинг 17. Пример хорошего метода работы #8: Подсчет числа строк с и без grep                 </p>
<p>~ $ time grep and tmp/a/longfile.txt | wc -l</p>
<p>2811</p>
<p>&nbsp;<p>real    0m0.097s</p>
<p>user    0m0.006s</p>
<p>sys     0m0.032s</p>
<p>~ $ time grep -c and tmp/a/longfile.txt</p>
<p>2811</p>
<p>&nbsp;<p>real    0m0.013s</p>
<p>user    0m0.006s</p>
<p>sys     0m0.005s</p>
<p>~ $ </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Опция -c является хорошим способом подсчета не только из-за фактора скорости. При использовании нескольких файлов grep с опцией -c возвращает отдельное значение для каждого файла, по одному на каждой строке, тогда как направление вывода в wc дает общий результат для всех файлов.</p>
<p>&nbsp;<p>Однако, этот пример интересен не только с точки зрения быстродействия – он иллюстрирует еще одну распространенную ошибку. Этот метод подсчета предоставляет только количество строк, в которых найдены соответствия образцу - и хорошо, если это то, что вы ищете. Но в случаях, где строки могут иметь несколько совпадений с конкретным образцом, эти методы не дадут реального числа соответствий образцу. Для подсчета числа совпадений используйте wc. Для начала запустите команду grep с опцией -o, если ваша версия поддерживает это. Эта опция выводит только соответствие образцу, по одному на каждую строку, но не саму строку. Ее нельзя использовать вместе с опцией -c, поэтому используйте wc -l для подсчета числа строк, как в следующем примере:</p>
<p>&nbsp;<p>Пример хорошего метода работы #8: Подсчет числа совпадений с образцом с grep                </p>
<p>~ $ grep -o and tmp/a/longfile.txt | wc -l</p>
<p>3402</p>
<p>~ $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>В этом случае обращение к wc работает немного быстрее, чем второй вызов grep с фиктивным образцом, позволяющим выполнить сравнение и подсчет каждой строки (как grep -c).</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Сравнение определенных полей вывода, не только строк</p>
<p>&nbsp;<p> Инструмент, подобный awk, предпочтительнее grep, когда вы хотите найти соответствие образцу только в конкретных полях строк вывода, а не во всей этой строке. </p>
<p>&nbsp;<p>Следующий упрощенный пример показывает, как отсортировать только те файлы, которые были изменены в декабре:</p>
<p>&nbsp;<p>Листинг 19. Пример плохого метода работы #9: Использование grep для поиска образца в определенных полях                </p>
<p>~/tmp $ ls -l /tmp/a/b/c | grep Dec</p>
<p>-rw-r--r--  7 joe joe  12043 Jan 27 20:36 December_Report.pdf</p>
<p>-rw-r--r--  1 root root  238 Dec 03 08:19 README</p>
<p>-rw-r--r--  3 joe joe   5096 Dec 14 14:26 archive.tar</p>
<p>~/tmp $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p> В этом примере grep фильтрует строки и выводит все файлы, в имени или дате изменения которых содержится Dec. Поэтому такой файл, как December_Report.pdf, подходит, даже если он не был изменен с января. Это, возможно, не то, что вы хотите. Для поиска соответствия образцу в конкретном поле лучше использовать awk, в котором относительный оператор соответствует конкретному полю, как показано в следующем примере</p>
<p>&nbsp;<p>Листинг 20. Пример хорошего метода работы #9: Использование awk для поиска образца в определенных полях                </p>
<p>~/tmp $ ls -l | awk '$6 == &quot;Dec&quot;'</p>
<p>-rw-r--r--  3 joe joe   5096 Dec 14 14:26 archive.tar</p>
<p>-rw-r--r--  1 root root  238 Dec 03 08:19 README</p>
<p>~/tmp $</p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p> Более подробно об использовании awk можно прочитать в разделе Ресурсы.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Не используйте передачу вывода cat</p>
<p>&nbsp;<p> Основная и распространенная ошибка в использовании grep заключается в передаче вывода cat в grep в grep для поиска по содержимому отдельного файла. Это абсолютно ненужная потеря времени, потому что такие инструменты, grep, принимают названия файлов в качестве аргументов. Поэтому использовать cat в этой ситуации совершенно не нужно, как в следующем примере:</p>
<p>&nbsp;<p>Листинг 21. Пример хорошего метода работы #10: Использование grep с cat и без него.                </p>
<p>~ $ time cat tmp/a/longfile.txt | grep and</p>
<p>2811</p>
<p>&nbsp;<p>real    0m0.015s</p>
<p>user    0m0.003s</p>
<p>sys     0m0.013s</p>
<p>~ $ time grep and tmp/a/longfile.txt</p>
<p>2811</p>
<p>&nbsp;<p>real    0m0.010s</p>
<p>user    0m0.006s</p>
<p>sys     0m0.004s</p>
<p>~ $ </p>
<p>&nbsp;<p>&nbsp;<p>&nbsp;<p>Эта ошибка допускается во многих случаях. Так как большинство инструментов получают стандартный ввод в виде аргумента, используя тире (-), даже аргумент для использования cat для разнообразия многочисленных файлов с stdin часто не действителен. На самом деле необходимо выполнить конкатенацию перед использованием cat с одной из его нескольких опций фильтрации.</p>
<p>&nbsp;<p>В начало</p>
<p>&nbsp;<p>Заключение: привыкайте к хорошему</p>
<p>&nbsp;<p>Мы рассмотрели несколько методов работы в командной строке. Плохие привычки замедляют работу и часто приводят к непредвиденным ошибкам. Эта статья рассказывает о 10 новых способах, которые могут помочь вам избавиться от многих наиболее распространенных ошибок. Привыкайте к этим хорошим методам и улучшайте свои навыки работы с командной строкой Unix.<span style="font-family:Sans Serif;"> </span></p>

</p></body></html>
